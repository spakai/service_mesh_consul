# Consul Service Discovery Example

This project demonstrates service discovery using [Consul](https://www.consul.io/) with two Python Flask microservices: **Service A** and **Service B**. Both services register themselves with Consul using mTLS (HTTPS with client certificates) and communicate with each other through Consul Connect sidecar proxies.

---

## Project Structure

```
certs/                    # TLS certificates (generated by script)
generate_consul_certs.sh  # Script to generate TLS certs
create_intentions.sh      # Script to create and test Consul intentions
service_a.py              # Service A Flask app
service_b.py              # Service B Flask app
```

---

## Prerequisites
- Python 3.7+
- [Consul](https://www.consul.io/downloads)
- Flask and Requests Python packages

---

## Setup and Running with Consul Connect (mTLS/HTTPS)

1. **Install Python dependencies:**
   ```bash
   pip install flask requests
   # or, if using Python 3:
   pip3 install flask requests
   ```

2. **Generate certificates:**
   ```bash
   bash generate_consul_certs.sh
   ```

3. **Start Consul agent (with TLS/HTTPS only):**
   ```bash
   consul agent -dev -config-file=consul/consul.hcl
   # This configures Consul to use HTTPS (port 8501) only, with mTLS required for all clients.
   ```

4. **Start Service B and its Connect sidecar:** (in a separate terminal)
   ```bash
   python3 service_b.py &
   consul connect proxy -sidecar-for service_b \
     -http-addr=https://127.0.0.1:8501 \
     -ca-file=certs/consul-agent-ca.pem \
     -client-cert=certs/dc1-client-consul-0.pem \
     -client-key=certs/dc1-client-consul-0-key.pem
   ```

5. **Start Service A and its Connect sidecar:** (in another terminal)
   ```bash
   python3 service_a.py &
   consul connect proxy -sidecar-for service_a \
     -http-addr=https://127.0.0.1:8501 \
     -ca-file=certs/consul-agent-ca.pem \
     -client-cert=certs/dc1-client-consul-0.pem \
     -client-key=certs/dc1-client-consul-0-key.pem
   ```

6. **Test Service A main endpoint:**
   ```bash
   curl http://localhost:5000/
   # Output: Hello from service_a!
   ```

7. **Test Service B endpoint directly:**
   ```bash
   curl http://localhost:5001/hello
   # Output: Hello from service_b!
   ```

8. **Test Service A calling Service B through Connect:**
   ```bash
   curl http://localhost:5000/call-b
   # Output: {"service_b_response": "Hello from service_b!"}
   ```

---

## Consul Intentions (Service-to-Service Authorization)

Consul Intentions control which services can communicate with each other in the service mesh. This project includes a script to demonstrate intention management.

### Using Intentions

1. **Create and test intentions:**
   ```bash
   ./create_intentions.sh
   ```
   This script will:
   - Create a deny intention preventing service_a from calling service_b
   - List all current intentions
   - Test that the intention is working (service_a â†’ service_b call should fail)

2. **Manual intention management:**
   ```bash
   # List all intentions
   consul intention list -http-addr=https://127.0.0.1:8501 \
     -ca-file=certs/consul-agent-ca.pem \
     -client-cert=certs/dc1-client-consul-0.pem \
     -client-key=certs/dc1-client-consul-0-key.pem

   # Create allow intention (using HTTP API)
   curl -k --cert certs/dc1-client-consul-0.pem --key certs/dc1-client-consul-0-key.pem \
     --request POST \
     --data '{"SourceName":"service_a","DestinationName":"service_b","Action":"allow"}' \
     https://127.0.0.1:8501/v1/connect/intentions

   # Create deny intention (using HTTP API)
   curl -k --cert certs/dc1-client-consul-0.pem --key certs/dc1-client-consul-0-key.pem \
     --request POST \
     --data '{"SourceName":"service_a","DestinationName":"service_b","Action":"deny"}' \
     https://127.0.0.1:8501/v1/connect/intentions
   ```

### Testing Intentions

- **With deny intention:** `curl http://localhost:5000/call-b` should fail
- **With allow intention:** `curl http://localhost:5000/call-b` should succeed
- **Direct service calls:** `curl http://localhost:5000/` and `curl http://localhost:5001/hello` should always work

---

## How Service Discovery Works
- Each service registers itself with Consul on startup using mTLS and the client certificates in `certs/`.
- Consul Connect sidecar proxies handle service-to-service mTLS automatically.
- Service A sends requests for Service B to its local sidecar proxy, which forwards them through the mesh.
- Intentions control which service-to-service communications are allowed or denied.

---

## Troubleshooting
- **All Consul API and proxy connections must use HTTPS (port 8501) and client certificates.**
- For curl/API calls, use:
  ```bash
  curl -k --cert certs/dc1-client-consul-0.pem --key certs/dc1-client-consul-0-key.pem https://127.0.0.1:8501/v1/agent/services
  ```
- If you see errors like `connection refused` on port 8500, ensure you are using `-http-addr=https://127.0.0.1:8501` for all Consul CLI/proxy commands.
- If you see `SSL routines::tlsv13 alert certificate required`, ensure you are providing the correct client certificate and key.
- For intention management, use the HTTP API with POST method as the CLI can have syntax issues.
- The Flask development server is not suitable for production workloads.

---

## License
MIT 